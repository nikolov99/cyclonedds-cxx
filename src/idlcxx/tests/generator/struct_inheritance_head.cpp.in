#include <algorithm>
#include <vector>
#include <cstring>
#include "org/eclipse/cyclonedds/topic/hash.hpp"

template<typename T> size_t write(const I &obj, T &stream) {
  (void)obj;
  size_t pos = stream.position();
  stream.write_primitive(obj.inherited_member());
  return stream.position() - pos;
}

template<typename T> size_t write(const s &obj, T &stream) {
  (void)obj;
  size_t pos = stream.position();
  write(dynamic_cast<const I&>(obj),stream);
  stream.write_primitive(obj.new_member());
  return stream.position() - pos;
}

template<typename T> size_t write_size(const I &obj, T &stream) {
  (void)obj;
  size_t pos = stream.position();
  stream.incr_primitive(obj.inherited_member());
  return stream.position() - pos;
}

template<typename T> size_t write_size(const s &obj, T &stream) {
  (void)obj;
  size_t pos = stream.position();
  write_size(dynamic_cast<const I&>(obj),stream);
  stream.incr_primitive(obj.new_member());
  return stream.position() - pos;
}

template<typename T> size_t write_size_max(const I &obj, T &stream) {
  (void)obj;
  size_t pos = stream.position();
  stream.incr_primitive(obj.inherited_member());
  return stream.position() - pos;
}

template<typename T> size_t write_size_max(const s &obj, T &stream) {
  (void)obj;
  size_t pos = stream.position();
  write_size_max(dynamic_cast<const I&>(obj),stream);
  stream.incr_primitive(obj.new_member());
  return stream.position() - pos;
}

template<typename T> size_t key_write_size(const I &obj, T &stream) {
  (void)obj;
  size_t pos = stream.position();
  return stream.position() - pos;
}

template<typename T> size_t key_write_size(const s &obj, T &stream) {
  (void)obj;
  size_t pos = stream.position();
  key_write_size(dynamic_cast<const I&>(obj),stream);
  return stream.position() - pos;
}

template<typename T> size_t key_write_size_max(const I &obj, T &stream) {
  (void)obj;
  size_t pos = stream.position();
  return stream.position() - pos;
}

template<typename T> size_t key_write_size_max(const s &obj, T &stream) {
  (void)obj;
  size_t pos = stream.position();
  key_write_size_max(dynamic_cast<const I&>(obj),stream);
  return stream.position() - pos;
}

template<typename T> size_t key_write(const I &obj, T &stream) {
  (void)obj;
  size_t pos = stream.position();
  return stream.position() - pos;
}

template<typename T> bool key_generate(const I &obj, T &stream, ddsi_keyhash_t &hash) {
  (void)obj;
  T stream_copy(stream);
  stream_copy.set_buffer(NULL);
  size_t sz = key_write_size(obj,stream_copy);
  size_t padding = 16 - sz%16;
  if (sz != 0 && padding == 16) padding = 0;
  std::vector<unsigned char> buffer(sz+padding);
  std::memset(buffer.data()+sz,0x0,padding);
  stream_copy.set_buffer(const_cast<unsigned char*>(buffer.data()));
  key_write(obj,stream_copy);
  static bool (*fptr)(const std::vector<unsigned char>&, ddsi_keyhash_t &) = NULL;
  if (fptr == NULL)
  {
    if (key_write_size_max(obj,stream_copy) <= 16)
    {
      //bind to unmodified function which just copies buffer into the keyhash
      fptr = &org::eclipse::cyclonedds::topic::simple_key;
    }
    else
    {
      //bind to MD5 hash function
      fptr = &org::eclipse::cyclonedds::topic::complex_key;
    }
  }
  return (*fptr)(buffer,hash);
}

template<typename T> size_t key_write(const s &obj, T &stream) {
  (void)obj;
  size_t pos = stream.position();
  key_write(dynamic_cast<const I&>(obj),stream);
  return stream.position() - pos;
}

template<typename T> bool key_generate(const s &obj, T &stream, ddsi_keyhash_t &hash) {
  (void)obj;
  T stream_copy(stream);
  stream_copy.set_buffer(NULL);
  size_t sz = key_write_size(obj,stream_copy);
  size_t padding = 16 - sz%16;
  if (sz != 0 && padding == 16) padding = 0;
  std::vector<unsigned char> buffer(sz+padding);
  std::memset(buffer.data()+sz,0x0,padding);
  stream_copy.set_buffer(const_cast<unsigned char*>(buffer.data()));
  key_write(obj,stream_copy);
  static bool (*fptr)(const std::vector<unsigned char>&, ddsi_keyhash_t &) = NULL;
  if (fptr == NULL)
  {
    if (key_write_size_max(obj,stream_copy) <= 16)
    {
      //bind to unmodified function which just copies buffer into the keyhash
      fptr = &org::eclipse::cyclonedds::topic::simple_key;
    }
    else
    {
      //bind to MD5 hash function
      fptr = &org::eclipse::cyclonedds::topic::complex_key;
    }
  }
  return (*fptr)(buffer,hash);
}

template<typename T> size_t key_read(I &obj, T &stream) {
  (void)obj;
  size_t pos = stream.position();
  return stream.position() - pos;
}

template<typename T> size_t key_read(s &obj, T &stream) {
  (void)obj;
  size_t pos = stream.position();
  key_read(dynamic_cast<I&>(obj),stream);
  return stream.position() - pos;
}

template<typename T> size_t read(I &obj, T &stream) {
  (void)obj;
  size_t pos = stream.position();
  stream.read_primitive(obj.inherited_member());
  return stream.position() - pos;
}

template<typename T> size_t read(s &obj, T &stream) {
  (void)obj;
  size_t pos = stream.position();
  read(dynamic_cast<I&>(obj),stream);
  stream.read_primitive(obj.new_member());
  return stream.position() - pos;
}

